<!doctype html><html lang="en" data-theme="light"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Deriving Dependently-Typed OOP from First Principles</title><script defer="defer" src="runtime.bundle.js"></script><script defer="defer" src="tutorial.bundle.js"></script></head><body><script>function jumpToHash(t){const e=`#${t}`;e!==location.hash?location.hash=e:window.dispatchEvent(new HashChangeEvent("hashchange"))}function switchToDark(){document.documentElement.setAttribute("data-theme","dark")}function switchToLight(){document.documentElement.setAttribute("data-theme","light")}window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&switchToDark()</script><main class="container"><section><h1>Deriving Dependently-Typed OOP from First Principles</h1><p>This is the web demo accompanying the OOPSLA 2024 paper Deriving Dependently-Typed OOP from First Principles. You will find the most recent version of the language on <a href="https://polarity-lang.github.io">polarity-lang.github.io</a>.</p><nav><ul><li><details role="list"><summary aria-haspopup="listbox" role="button" class="secondary">Examples</summary><ul role="listbox"><li><a onclick='jumpToHash("ChurchEncodingCodata.pol")'>ChurchEncodingCodata</a></li><li><a onclick='jumpToHash("ChurchEncodingData.pol")'>ChurchEncodingData</a></li><li><a onclick='jumpToHash("Constraints-CodataFunEq.pol")'>Constraints-CodataFunEq</a></li><li><a onclick='jumpToHash("Constraints-DataFunEq.pol")'>Constraints-DataFunEq</a></li><li><a onclick='jumpToHash("Expressions-CaseStudy-After.pol")'>Expressions-CaseStudy-After</a></li><li><a onclick='jumpToHash("Expressions-CaseStudy-Before.pol")'>Expressions-CaseStudy-Before</a></li><li><a onclick='jumpToHash("FuStumpEncodingCodata.pol")'>FuStumpEncodingCodata</a></li><li><a onclick='jumpToHash("FuStumpEncodingData.pol")'>FuStumpEncodingData</a></li><li><a onclick='jumpToHash("FutureWork-After.pol")'>FutureWork-After</a></li><li><a onclick='jumpToHash("FutureWork-Before.pol")'>FutureWork-Before</a></li><li><a onclick='jumpToHash("FutureWork-IntSet.pol")'>FutureWork-IntSet</a></li><li><a onclick='jumpToHash("FutureWork-Setoid.pol")'>FutureWork-Setoid</a></li><li><a onclick='jumpToHash("Intro-BoolAfter.pol")'>Intro-BoolAfter</a></li><li><a onclick='jumpToHash("Intro-BoolAfterSimple.pol")'>Intro-BoolAfterSimple</a></li><li><a onclick='jumpToHash("Intro-BoolBefore.pol")'>Intro-BoolBefore</a></li><li><a onclick='jumpToHash("Intro-BoolBeforeSimple.pol")'>Intro-BoolBeforeSimple</a></li><li><a onclick='jumpToHash("Intro-Fun-Lambda.pol")'>Intro-Fun-Lambda</a></li><li><a onclick='jumpToHash("Intro-StreamI.pol")'>Intro-StreamI</a></li><li><a onclick='jumpToHash("Intro-StreamII.pol")'>Intro-StreamII</a></li><li><a onclick='jumpToHash("OOP-Buffer.pol")'>OOP-Buffer</a></li><li><a onclick='jumpToHash("OOP-CodataBool.pol")'>OOP-CodataBool</a></li><li><a onclick='jumpToHash("OOP-EvenOddAfter.pol")'>OOP-EvenOddAfter</a></li><li><a onclick='jumpToHash("OOP-EvenOddBefore.pol")'>OOP-EvenOddBefore</a></li><li><a onclick='jumpToHash("OOP-ExistentialsNeg.pol")'>OOP-ExistentialsNeg</a></li><li><a onclick='jumpToHash("OOP-ExistentialsPos.pol")'>OOP-ExistentialsPos</a></li><li><a onclick='jumpToHash("OOP-Neg.pol")'>OOP-Neg</a></li><li><a onclick='jumpToHash("OOP-NegInverse.pol")'>OOP-NegInverse</a></li><li><a onclick='jumpToHash("OOP-PR.pol")'>OOP-PR</a></li><li><a onclick='jumpToHash("OOP-Pi.pol")'>OOP-Pi</a></li><li><a onclick='jumpToHash("OOP-ProductsNeg.pol")'>OOP-ProductsNeg</a></li><li><a onclick='jumpToHash("OOP-ProductsPos.pol")'>OOP-ProductsPos</a></li><li><a onclick='jumpToHash("OOP-SigmaNeg.pol")'>OOP-SigmaNeg</a></li><li><a onclick='jumpToHash("OOP-SigmaPos.pol")'>OOP-SigmaPos</a></li><li><a onclick='jumpToHash("OOP-Vec-example.pol")'>OOP-Vec-example</a></li><li><a onclick='jumpToHash("ParigotEncodingCodata.pol")'>ParigotEncodingCodata</a></li><li><a onclick='jumpToHash("ParigotEncodingData.pol")'>ParigotEncodingData</a></li><li><a onclick='jumpToHash("STLC.pol")'>STLC</a></li><li><a onclick='jumpToHash("ScottEncodingCodata.pol")'>ScottEncodingCodata</a></li><li><a onclick='jumpToHash("ScottEncodingData.pol")'>ScottEncodingData</a></li><li><a onclick='jumpToHash("Webserver-After.pol")'>Webserver-After</a></li><li><a onclick='jumpToHash("Webserver-Before.pol")'>Webserver-Before</a></li></ul></details></li><li><details role="list"><summary aria-haspopup="listbox" role="button" class="secondary">Theme</summary><ul role="listbox"><li><a onclick="switchToLight()">Light</a></li><li><a onclick="switchToDark()">Dark</a></li></ul></details></li></ul></nav></section><section><div class="editor-container"><iframe class="editor-frame" id="editor-frame" src="./editor"></iframe></div></section><section id="tutorial"><h4>Tutorial</h4><p>This is a short overview of the syntax of our language. Feel free to copy and paste sections of the tutorial code into the interactive editor above to try out the examples on your own.</p><details><summary><b>Data Types</b></summary><p>The simplest form of data types do not have parameters or indices. In that case, the constructors of the data type can be given as a comma-separated list. As with all syntactic constructs, we always allow trailing commas.</p><pre><code class="language-pol">data Bool { True, False, }
</code></pre><p>In the more general case we have to specify the precise type that a constructor constructs. Therefore, the above data type declaration can be written more explicitly as:</p><pre><code class="language-pol">data Bool { True: Bool, False: Bool }
</code></pre><p>A simple example of a parameterized type is the type of singly-linked lists of some type <code>a</code>. In that case, we have to specify both the parameters of the type constructor <code>List</code>, and the instantiations of the term constructors <code>Nil</code> and <code>Cons</code>. For the parameter of the type constructor <code>List</code> we make use of the impredicative type universe, which is written <code>Type</code>.</p><pre><code class="language-pol">data List(a: Type) {
  Nil(a: Type): List(a),
  Cons(a: Type, x: a, xs: List(a)): List(a)
}
</code></pre><p>A proper dependent type is the type of length-indexed lists: the vector type. The <code>VNil</code> and <code>VCons</code> constructors of vectors create vectors with different indices.</p><pre><code class="language-pol">data Nat { Z, S(n: Nat) }
data Vec(a: Type, n: Nat) {
  VNil(a: Type): Vec(a, Z),
  VCons(a: Type, n: Nat, x: a, xs: Vec(a, n)): Vec(a, S(n))
}
</code></pre><p>Finally, we can define the Martin-LÃ¶f equality type as follows:</p><pre><code class="language-pol">data Eq (a: Type, x y: a) {
    Refl(a: Type, x: a) : Eq(a, x, x)
}
</code></pre></details><details><summary><b>Codata Types</b></summary><p>Codata types are specified by a list of methods or destructors. A very simple example is the type of pairs of a boolean and a natural number:</p><pre><code class="language-pol">data Bool { True, False }
data Nat { Z, S(n: Nat)}
codata Pair {
  proj1: Bool,
  proj2: Nat
}
</code></pre><p>This type supports two observations; the first observations <code>proj1</code> yields a boolean value when invoked on a <code>Pair</code>, and the observation <code>proj2</code> yields a natural number.</p><p>A common codata type that is typically built into many programming languages is the function type. In our language, it is not built-in, but we can define it as follows:</p><pre><code class="language-pol">codata Fun(a b: Type) {
    Fun(a, b).ap(a: Type, b: Type, x: a) : b
}
</code></pre><p>Codata types can also model infinite types. The type of infinite streams is a classical example and written like this:</p><pre><code class="language-pol">codata Stream(a: Type) {
  Stream(a).head(a: Type) : a,
  Stream(a).tail(a: Type) : Stream(a),
}
</code></pre><p>Sometimes we also need to reference the object on which a method is invoked in its return type. This is especially the case when we want an observation to yield a proof that the object satisfies some property. Here is a simple example which shows how this can be expressed:</p><pre><code class="language-pol">codata Bool {
  Bool.neg : Bool,
  (x: Bool).neg_inverse : Eq(Bool, x, x.neg.neg),
}
</code></pre></details><details><summary><b>Definitions</b></summary><p>Definitions create a consumer (method) for a data type. These consumers receive an implicit input on which they pattern match. As a simple example, we can define Boolean negation as follows:</p><pre><code class="language-pol">def Bool.neg: Bool {
    True =&gt; False,
    False =&gt; True,
}
</code></pre><p>Definitions can be recursive. For instance, we can define addition on natural numbers as follows:</p><pre><code class="language-pol">def Nat.add(y: Nat) : Nat {
    Z =&gt; y,
    S(x) =&gt; S(x.add(y)),
}
</code></pre><p>Definitions can also deal with parametrized types. For instance, we can define a <code>map</code> method for the data type <code>List</code> as follows:</p><pre><code class="language-pol">def List(a).map(a b: Type, f: Fun(a, b)): List(b) {
    Nil(a) =&gt; Nil(b),
    Cons(a, x, xs) =&gt; Cons(b, f.ap(a, b, x), xs.map(a, b, f)),
}
</code></pre><p>Finally, to illustrate dependently typed definitions, let us give the classic example of defining <code>append</code> on length-indexed lists:</p><pre><code class="language-pol">def Vec(a, n).append(a: Type, n m: Nat, ys: Vec(a, m)) : Vec(a, n.add(m)) {
    VNil(a) =&gt; ys,
    VCons(a, n&#39;, x, xs) =&gt; VCons(a, n&#39;.add(m), x, xs.append(a, n&#39;, m, ys))
}
</code></pre><p>Last, but certainly not least, the return type of a definition may not only depend on its parameters but also on its (implicit) input. To do so, we can make the input explicit by assigning it a name. For instance, we can prove that Boolean negation is its own inverse as follows:</p><pre><code class="language-pol">def (x: Bool).neg_inverse: Eq(Bool, x, x.not.not) {
    True =&gt; Refl(Bool, True),
    False =&gt; Refl(Bool, False)
}
</code></pre></details><details><summary><b>Codefinitions</b></summary><p>Codefinitions create producers (or objects) for codata types. They need to define the behavior of the object when each of its destructors is invoked. Analogously to pattern matching, where we pattern match on the constructors of a data type, we <em>copattern match</em> on the destructors of a codata type. For example, we can create a pair with the <code>Pair</code> codata type defined above as follows:</p><pre><code class="language-pol">codef MyPair: Pair {
    proj1 =&gt; True,
    proj2 =&gt; 42,
}
</code></pre><p>We can retrieve the values in the pair by invoking one of the destructors. For instance, <code>MyPair.proj2</code> will yield the result of <code>42</code>.</p><p>Codefinitions can also be used to construct infinite objects. For instance, we can generate an infinite stream that counts upwards as follows:</p><pre><code class="language-pol">codef CountUp(n: Nat): Stream(Nat) {
    head(_) =&gt; n,
    tail(_) =&gt; CountUp(S(n)),
}
</code></pre><p>Finally, codefinitions can also return proofs that they fulfill certain properties:</p><pre><code class="language-pol">codef True: Bool {
    not =&gt; False,
    neg_inverse =&gt; Refl(Bool, True),
}

codef False: Bool {
    not =&gt; True,
    neg_inverse =&gt; Refl(Bool, False),
}
</code></pre></details><details><summary><b>Comments</b></summary><p>Line comments are written using two dashes: <code>-- This is a comment</code>. Certain items of the program can also be annotated with a documentation comment. Here is an example using doc-comments:</p><pre><code class="language-pol">-- | The type of booleans
data Bool {
  -- | The boolean truth value
  True,
  -- | The boolean false value
  False,
}
</code></pre><p>These documentation comments are preserved during defunctionalization and refunctionalization.</p></details><details><summary><b>Typed Holes</b></summary><p>An incomplete program can be written using typed holes. Typed holes are written using either <code>?</code>; they have type <code>?</code> which unifies with any other type. For example, an incomplete implementation of boolean negation can be written as follows:</p><pre><code class="language-pol">def Bool.neg : Bool {
  True =&gt; ?,
  False =&gt; ?,
}
</code></pre></details><details><summary><b>The Main Expression</b></summary><p>After all other data types, codata types, definitions and codefinitions an additional expression can be written. This is called the &quot;main&quot; expression of the program.</p><pre><code class="language-pol">data Bool { True, False }
def Bool.neg {
  True =&gt; False,
  False =&gt; True,
}
True.neg
</code></pre></details></section></main></body></html>